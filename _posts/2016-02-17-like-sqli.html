---
layout: post
title: SQL LIKE clauses wildcard injection
date: '2016-02-17T08:00:00.000+01:00'
author: Ramon Pinuaga
tags:
- WebSecurity
- SQLi
modified_time: '2016-02-17T08:04:42.576+01:00'
thumbnail: https://3.bp.blogspot.com/-9JpWIgk1pz8/VreFaqqDBAI/AAAAAAAAALE/Dsd9431sLR8/s72-c/login.png
blogger_id: tag:blogger.com,1999:blog-9163961975500012189.post-1019153737703966059
blogger_orig_url: http://www.en.pentester.es/2016/02/like-sqli.html
---

I’m going to talk about a little known vulnerability and traditionally considered of low risk, although as we are going to see in some situations it can have a big impact.<br /><br />This vulnerability involves the possibility of injecting a wildcard in the search field of a LIKE clause in a SQL statement.<br /><br />OWASP covers briefly this kind of <a href="https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Escaping_Wildcard_characters_in_Like_Clauses">injections</a> in its guides.<br /><br />In SQL we have 2 types of wildcards:<br /><ul><li>% equivalent to any string of cero or more characters.</li><li>_ equivalent to any character.</li></ul>An application is vulnerable to this attack when it uses the LIKE operator with a user received parameter not filtering any of these 2 wildcards.<br /><br />For example if we have the following URL:<br /><a href="http://www.example.com/fruit.php?name=apple">http://www.example.com/fruit.php?name=apple</a><br /><br />That shows a text extracted from the database with a SQL query like the following:<br /><a href="http://SELECT%20text%20FROM%20table%20WHERE%20fruit%20LIKE%20%E2%80%98$name%E2%80%99/">SELECT text FROM table WHERE fruit LIKE ‘$name’</a><br /><br />Instead of using the simple form:<br /><a href="http://SELECT%20text%20FROM%20table%20WHERE%20fruit=%E2%80%98$name%E2%80%99/">SELECT text FROM table WHERE fruit=‘$name’</a><br /><br />Even if the $name parameter is sanitized for avoiding SQL injection (for example filtering the single quote) it’s still possible to inject wildcards in the search field, as following:<br /><a href="http://www.example.com/fruit.php?name=ap%">http://www.example.com/fruit.php?name=ap%</a><br /><br />In an application like this, altering the search logic it’s not critical, but what happens if we have another application like the following? (Where we don’t know the name of the users).<br /><a href="http://www.example.com/userphoto.php?name=john">http://www.example.com/userphoto.php?name=john</a><br /><br />We can easily do the following and obtain a listing of all available users:<br /><a href="http://www.example.com/userphoto.php?name=a%">http://www.example.com/userphoto.php?name=a%</a><br /><a href="http://www.example.com/userphoto.php?name=b%">http://www.example.com/userphoto.php?name=b%</a><br /><a href="http://www.example.com/userphoto.php?name=c%">http://www.example.com/userphoto.php?name=c%</a><br />…<br /><br />We can automate the process with a simple script that will go pulling the names of each user character by character (like in the war games movie).<br /><br />In what situations this kind of vulnerabilities can be dangerous?<br /><br /><ul><li>In login forms. I have found sometimes this vulnerability in the “username” field of some forms and less commonly even in the “password” field.</li><li>In password recovery forms. This vulnerability can allow us to reset the password of other users.</li><li>In fields containing session identifiers or tokens. This vulnerability can allow us to “steal” or “predict” the tokens or the sessions ids of other users.</li></ul><br />It’s incredible but this works sometimes:<br /><a href="http://3.bp.blogspot.com/-9JpWIgk1pz8/VreFaqqDBAI/AAAAAAAAALE/Dsd9431sLR8/s1600/login.png" imageanchor="1"><img border="0" src="https://3.bp.blogspot.com/-9JpWIgk1pz8/VreFaqqDBAI/AAAAAAAAALE/Dsd9431sLR8/s1600/login.png" /></a><br />The injection of the % wildcard sometimes can be hard, because this character is usually filtered to avoid encoding attacks o precisely because it is wrongly decoded (in this case we can replace it by %25 or %2525).<br /><br />Some time ago I found a curious situation where an application authenticated users with a session identifier stored in a database. The extraction of the values stored was made with a vulnerable query, this way:<br /><a href="http://www.example.com/admin/private.php?sessionid=0123456789">http://www.example.com/admin/private.php?sessionid=0123456789</a><br /><br />The server filtered the % wildcard, but the _ character was permitted. With the following trick we could exploit the vulnerability:<br /><a href="http://www.example.com/admin/privado.php?sessionid=__________">http://www.example.com/admin/privado.php?sessionid=__________</a><br /><br />If we wanted to access a specific session, we only needed to do a sweep:<br /><a href="http://www.example.com/admin/privado.php?sessionid=0_________">http://www.example.com/admin/privado.php?sessionid=0_________</a><br /><a href="http://www.example.com/admin/privado.php?sessionid=1_________">http://www.example.com/admin/privado.php?sessionid=1_________</a><br /><a href="http://www.example.com/admin/privado.php?sessionid=2_________">http://www.example.com/admin/privado.php?sessionid=2_________</a><br />…<br /><br />Why some programmers fall with this evident bug?<br /><br />I suppose that sometimes it’s only an oversight, but I have detected that some programming frameworks encapsulate the SQL statements transparently for the programmer but internally they use the LIKE operator, without him even knowing.<br /><br />For example the following Django sentence:<br /><a href="http://result%3dentry.objects.get%28headline__contains%3d%27lennon%27%29/">result=Entry.objects.get(headline__contains='Lennon')</a><br /><br />Results in:<br /><a href="http://select%20...%20where%20headline%20like%20%27%25lennon%25%27/">SELECT ... WHERE headline LIKE '%Lennon%'</a><br /><br />This can easily lead to multiple vulnerabilities if the developer is not careful.<br /><br />Also this other <a href="https://github.com/FriendsOfSymfony/FOSUserBundle/issues/1688">bug</a> very similar in the Propel module of Symfony.