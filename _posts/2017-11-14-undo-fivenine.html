---
layout: post
title: Undo Five/Nine (Crypto 300, Lisbon CTF)
date: '2017-11-14T09:00:00.000+01:00'
author: Jose Selvi
tags:
- bsides
- crypto
- ctf
- php
modified_time: '2017-11-14T09:27:01.010+01:00'
blogger_id: tag:blogger.com,1999:blog-9163961975500012189.post-7110821079957881596
blogger_orig_url: http://www.en.pentester.es/2017/11/undo-fivenine.html
---

<div style="text-align: justify;">Last week I had the opportunity to participate in the on-site Bsides Lisbon CTF. I teamed up with some workmates and we tried to solve some of the challenges.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">One of the challenges I was working on was "Crypto 300: Undo Five/Nine". I didn't take notes on the description, but basically they gave a piece of PHP code "<i>snip.php</i>" and two other files: "<i>readme.txt</i>" and "<i>readme.txt.fsociety</i>".</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">A quick look at "<i>snip.php</i>" helps us to understand how the other two files were used or generated:</div><br /><i><span style="margin-left: 2em;">$crypted = fopen($file . ".fsociety", "w");</span></i><br /><i><span style="margin-left: 2em;">$fp = fopen($file, "r+");</span></i><br /><i><span style="margin-left: 2em;">$clear = fread($fp, 2048);</span></i><br /><i><span style="margin-left: 2em;">// destroy original file</span></i><br /><i><span style="margin-left: 2em;">destroy_file($fp,strlen($clear));</span></i><br /><i><span style="margin-left: 2em;"><br /></span></i><i><span style="margin-left: 2em;">// generate unique key</span></i><br /><i><span style="margin-left: 2em;">$key = gen_aes_key();</span></i><br /><i><span style="margin-left: 2em;">$aes = new Crypt_AES(CRYPT_AES_MODE_ECB);</span></i><br /><i><span style="margin-left: 2em;">$aes-&gt;setKeyLength(128);</span></i><br /><i><span style="margin-left: 2em;">$aes-&gt;setKey($key);</span></i><br /><i><span style="margin-left: 2em;"><br /></span></i><i><span style="margin-left: 2em;">// create encrypted file</span></i><br /><i><span style="margin-left: 2em;">$clear = $aes-&gt;encrypt($clear);</span></i><br /><i><span style="margin-left: 2em;">fwrite($crypted,$clear,strlen($clear));</span></i><br /><br /><div style="text-align: justify;">As we can see, it seems this PHP script read a plaintext secret from "<i>readme.txt</i>" and destroys it somehow. Then an encryption key is generated and the plaintext is encrypted using AES-128 in ECB mode. The encrypted secret is then stored in "<i>readme.txt.fsociety</i>".</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So it seems we should be able to recover that encrypted message somehow. Since key is not stored, it was obvious that we were facing some kind of weakness in that key generation. Let's have a look:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">function gen_aes_key() {</span></i></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">&nbsp;$key = "";</span></i></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">&nbsp;for ($i = 0;$i &lt; 16;$i++)</span></i></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">&nbsp; <b>&nbsp;$key.= chr(mt_rand(0, 255));</b></span></i></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">&nbsp;return $key;</span></i></div><div style="text-align: justify;"><i><span style="margin-left: 2em;">}</span></i></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Well, that makes sense. "<a href="http://php.net/manual/en/function.mt-rand.php" target="_blank">mt_rand</a>" function generates a random value via the Mersenne Twister Random Number Generator. This function, as its documentation warns, is not secure for cryptographic purposes. I googled for a while, and I found <a href="http://www.openwall.com/php_mt_seed/" target="_blank">more information about this issue</a>, where we can find the following information:</div><br /><div style="text-align: justify;"><i>"Common misuses of mt_rand() include generation of anti-CSRF tokens, custom session tokens (not relying on PHP's builtin sessions support, which uses a different PRNG yet was also vulnerable until recently), password reset tokens, passwords, database backup filenames, etc. If one of these items is exposed and another is generated later without the web application or server reseeding the PRNG, then an attack is possible where the seed is cracked from the item generated earlier and is then used to infer the unknown item generated later."</i></div><div><br /></div><div style="text-align: justify;">It seems we should have at least another call to "<i>mt_rand</i>" and to have access to its results in order to be able to exploit this issue, but we only have an encrypted message, and a destroyed file. Let's have a look to the piece of code that destroys that file:</div><div><br /></div><div><div><i><span style="margin-left: 2em;">function destroy_file($fp,$len) {</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; $random = "";</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; for ($i = 0;$i &lt; $len;$i++)</span></i></div><div><i><span style="margin-left: 2em;"><b>&nbsp; &nbsp; $random.= chr(mt_rand(0, 255));</b></span></i></div><div><i><span style="margin-left: 2em;">&nbsp; fseek($fp, 0);</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; fwrite($fp, substr($random, 0, $len));</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; fclose($fp);</span></i></div><div><i><span style="margin-left: 2em;">}</span></i></div></div><div><br /></div><div style="text-align: justify;">Bingo! It was overwritten using "random" values generates with the same function, which means that if we can obtain the seed, we could regenerate all the stream and grab the encryption key.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Let's do it! I was reading the <a href="http://www.openwall.com/php_mt_seed/" target="_blank">seed cracker</a> documentation for a while. It wasn't as easy as I initially thought, since this tool has several modes of operation, but I finally understood that the proper syntax was as follows:</div><div><br /></div><div style="text-align: center;"><div style="text-align: left;"><i><span style="margin-left: 2em;">$&nbsp;<b></b></span>./php_mt_seed [first_num] [first_num] 0 255 [second_num] [second_num] 0 255 ...</i></div></div><div><br /></div><div>But I had a bunch of bytes, so I decided to generate it using a few lines of PHP code:</div><div><br /></div><div><div><i><span style="margin-left: 2em;">$fp = fopen("readme.txt", "r+");</span></i></div><div><i><span style="margin-left: 2em;">$clear = str_split( fread($fp, 2048) );</span></i></div><div><i><span style="margin-left: 2em;">foreach ($clear as $v) {</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; &nbsp; echo ord($v) . ' ' . ord($v) . " 0 255 ";</span></i></div><div><i><span style="margin-left: 2em;">}</span></i></div></div><div><br /></div><div>This code generated of the parameter that I needed. In a minute or two, I got an answer: "<b>844114388</b>". Now we need to regenerate all the stream based on this seed. Let's go back to a piece of PHP code:</div><div><br /></div><div><div><i><span style="margin-left: 2em;">mt_srand(844114388);</span></i></div><div><i><span style="margin-left: 2em;">for ($i = 0;$i &lt; 64;$i++)</span></i></div><div><i><span style="margin-left: 2em;">&nbsp; &nbsp; echo chr(mt_rand(0, 255));</span></i></div></div><div><br /></div><div style="text-align: justify;">When we generate this stream, we will see a number of bytes that should be the same to the information we can found in "readme.txt". After those bytes, we should have the encryption key (16 bytes).</div><div><br /></div><div><div><i><span style="margin-left: 2em;">$ php gen.php &nbsp;| xxd</span></i></div><div><i><span style="margin-left: 2em;">00000000: 7b36 0ee9 f9b9 1cfe d0bb d0e6 1311 5828 &nbsp;{6............X(</span></i></div><div><i><span style="margin-left: 2em;">00000010: fcfe 84a6 7453 03f6 85b6 e270 76c3 41f8 &nbsp;....tS.....pv.A.</span></i></div><div><i><span style="margin-left: 2em;">00000020: aec4 9ca5 <b>f658 dda4 20f2 1c9f 5d14 b5b1</b> &nbsp;.....X.. ...]...</span></i></div><div><i><span style="margin-left: 2em;">00000030: <b>beb5 1669</b> 3135 31f9 30bc 9438 d0ac d0d6 &nbsp;...i151.0..8....</span></i></div></div><div><br /></div><div>So let's see if we can decrypt the file:<br /><br /><i><span style="margin-left: 2em;">$ openssl enc -aes-128-ecb -d -K "f658dda420f21c9f5d14b5b1beb51669" -in readme.txt.fsociety</span></i><br /><i><span style="margin-left: 2em;">flag{the_darkarmy_is_now_on_to_you}</span></i><br /><br /><div style="text-align: justify;">Bang! We got it! Unfortunately, I wasn't able to submit this flag. Why? First because, for some reason, I had in mind that "snip.php" was generating integers and then they were being truncated, so I spend around an hour reading the tool and trying to modify it. Second, because I got a syntax error on my code 10 seconds before CTF's deadline, so I wasn't able to fix it and to submit the flag. Anyway, I enjoyed the CTF :)</div></div>